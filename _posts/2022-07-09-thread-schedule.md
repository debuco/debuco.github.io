---
layout:     post
title:      "[操作系统] 进程/线程调度"
date:       2022-07-09 22:39:00
author:     "Neo"
catalog: true
header-style: text
tags:
    - 操作系统


---

 **上下文切换**

* 切换CPU的当前人去，从一个进程/线程到另一个
* 保存当前进程/线程在PCB/TCB的执行上下文（CPU状态）
* 读取一个进程/线程的上下文

**CPU调度**

* 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程
* 调度程序：挑选进程/线程的内核函数
* 什么时候进行调度？



# 什么时候进行调度

进程/线程的生命周期

<img src="/img/生命周期.png" style="zoom: 16%;" />

**内核进行调度程序的条件（满足一条即可）**

* 一个进程从运行状态切换到等待状态
* 一个进程被终结了

**不可抢占**

* 调度程序必须等待事件结束

**可以抢占**

* 调度程序在中断被响应后执行
* 当前的进程从运行切换到就绪，活着从一个进程从等待切换到就绪
* 当前运行的进程可以被换出

# 调度原则

调度时选择进程的依据。

评价指标：

* CPU使用率

  > CPU处于忙状态所占时间的百分比

* 吞吐量

  > 在单位时间内完成的进程数量

* 周转时间

  > 一个进程从初始化到结束，包括所有等待时间所花费的时间

* 等待时间

  > 进程在就绪队列中的总时间

* 响应时间

  > 一个请求被提交到产生第一次响应所花费的总时间

* 公平

  > 保证每个进程占用相同的CPU时间

# 调度算法

[操作系统-调度算法](https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/)

1. FCFS

   * 先来先服务，不考虑抢占

   * Firstn Come, First Served

   > 优点：
   >
   > 简单
   >
   > 缺点：
   >
   > * 平均等待时间波动大
   > * 花费时间少的任务可能排在花费时间长的任务后面
   > * 可能导致I/O和CPU之间的重叠处理
   > * CPU密集型进程会导致I/O设备闲置时，I/O密集进程也在等待

2. SPN(SJF) SRT

   * 短作业优先，可以考虑抢占或者不抢占
   * Shortest Process Next(Shortest Job First) Shortest Remaining Time

   >  最优平均等待时间
   >
   > 缺点：
   >
   > * 可能导致饥饿
   >   * 连续的短任务流会使长任务饥饿
   >   * 短任务可用时的任何场任务的CPU时间都会增加平均等待时间
   > * 需要预知未来

3. HRRN

   * 最高响应比优先
   * 不可抢占
   * 关注进程等待了多长时间，解决饥饿问题
   * 防止无限期推迟

   * Highest Response Ratio Next

4. **Round Robin（公平）**

   * 轮询，使用时间片和抢占轮询来执行任务

   > 花销：额外的上下文切换
   >
   > 时间量子大：
   >
   > * 等待时间长
   > * 极限情况退化成FCFS
   >
   > 时间量子小：
   >
   > * 反应迅速
   > * 吞吐量由于大量的上下文切换开销受到影响

5. **Multilevel Feedback Queues**（**公平，响应**）

   * 多级反馈队列
   * 优先级队列中的轮询

6. Fair Share Scheduling

   * 公平共享调度

# 实时调度

多服务于实时系统，工业控制，嵌入式环境。任务需要在规定时间段内完成。

定义：

> 正确性依赖于其时间和功能两方面的操作系统

指标：

> 时间约束的及时性
>
> 速度和平均性能相对不重要

特性：

> 时间约束的可预测性

分类：

> * 强实时系统
>
>   任务需要在保证的时间内完成
>
> * 弱实时
>
>   要求重要的优先级更高，尽量完成

# 多处理器的CPU调度



