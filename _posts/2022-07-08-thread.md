---
layout:     post
title:      "[操作系统] 线程概述"
date:       2022-07-08 22:23:00
author:     "Neo"
catalog: true
header-style: text
tags:
    - 操作系统

---

# 线程

> * 实体间可以并发的执行
> * 实体之间共享相同的地址空间

进程当中的一条执行流程。



**重新理解进程**：

* 从资源组合的角度：

  进程将一组相关的资源组合起来，构成一个资源平台（环境）

  * 地址空间
    * 代码段
    * 数据段
    * 打开的文件等各种资源

* 从运行的角度：

  * 代码在这个资源平台上的一条执行流程（线程） 



**线程的优点**：

* 一个进程中可以同时存在多个线程；
* 各个线程之间可以并发地执行；
* 各个线程之间可以共享地址空间和文件等资源；

**线程的缺点**：

* 一个线程崩溃，会导致其所属进程的所有线程崩溃



**线程与进程的比较**

* 进程是资源分配单位，线程是CPU调度单位
* 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
* 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系
* 线程能减少并发执行的时间和空间开销
  * 线程的创建时间比进程短
  * 线程的终止时间比进程短
  * 同一进程内的线程切换时间比进程短
  * 由于同一进程的各线程间共享内存和文件资源，可直接进行不通过内核的通信



# 线程的实现方式

* 用户线程
* 内核线程
* 轻量级进程



## 用户线程：在用户空间实现

* POSIX Pthreads, Mach C-threads, Solaris threads
* 用户空间实现的线程机制，不依赖于操作系统的内核，由一组用户级的线程函数来完成线程的管理，包括进程的创建、终止、同步和调度等
  * 用于用户线程的维护由相应进程来完成，不需要操作系统内核了了解用户线程的存在，可用于不支持现层高技术的多进程操作系统列表，用来跟踪记录它的各个线程的状态信息（PC、栈指针、寄存器），TCB由线程库函数来维护；
  * 每个进程都需要它自己私有的线程控制块（TCB）；
  * 用户线程的切换也是由线程库函数来完成，无需用户态/核心态切换，所以速度特别快
  * 允许每个进程拥有自定义的线程调度算法
* 缺点：
  * 阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待
  * 当一个线程开始运行后，除非它主动的交出CPU的，否则它所在的进程当中的其他线程将无法执行
  * 由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢

<img src="/img/用户线程1.png" style="zoom:67%;" />



<img src="/img/用户线程.png" style="zoom:50%;" />



## 内核线程：在内核中实现

* Windows, Solaris, Linux
* 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）；
* 线程的创建、终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销较大
* 在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其它内核线程的运行
* 时间片分配给线程，多线程的进程获得更多CPU时间

<img src="/img/内核线程1.png" style="zoom:70%;" />



## 轻量级进程：在内核中实现，支持用户线程

* Solaris
* 它是内核支持的用户线程，有个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。

<img src="/img/轻量级进程.png" style="zoom:50%;" />



<img src="/img/用户线程与轻量级进程之间.png" style="zoom:50%;" />

## 上下文切换

停止当前运行进程（从运行状态改编成其它状态）并且调度其他进程（转变成运行状态）。

* 必须在切换之前存储许多部分的进程上下文
* 必须能够在之后恢复他们，所以进程不能显示它曾经被暂停过
* 必须快速

需要存储的上下文？

* 寄存器（PC，SP，...）,CPU状态，...

<img src="/img/上下文切换.png" style="zoom:80%;" />

